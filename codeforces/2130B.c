#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#define DEBUG
//#define INPUT_FILE

#ifdef INPUT_FILE
#define INPUT fp
#else
#define INPUT stdin
#endif

static char buffer[150];
static int s;
static int n;
static int a[50];
static int go_through;
static int n_of_v[3];		// number of 0, 1, 2 // non-used
static int remainder;		// s - go_through
static int repeat_add[5]; 	// 0 0:0, 0 1:1, ..., 2 2:4 
							// 0, 1, 2, 3, 4
							// We need to consider whether remainder can be generated by x, that non-zero repeat_add[x] != 0
							// So, if repeat_add[1] != 0 -> invalid

#ifdef INPUT_FILE
static FILE *fp;
#endif

int put_element(int index, int element);
void remove_element(int index, int element);
int recv_f(int index);
int check_arrange_good(void);

void testcase_read(void) {
	char *p;
	int i;

	// Initialize variables
	go_through = n_of_v[0] = n_of_v[1] = n_of_v[2] = 0;
	for(i = 0; i < 5; i++)
		repeat_add[i] = 0;

	// get input: n s
	fgets(buffer, sizeof(buffer), INPUT);
	sscanf(buffer, "%d %d", &n, &s);

	// get input: a1 a2 a3 ...
	fgets(buffer, sizeof(buffer), INPUT);
	for (p = buffer, i = 0; i < n; p++) {
		if (*p == ' ')
			continue;
		a[i] = *p - '0';
		go_through += a[i];
		n_of_v[a[i]]++;
		if (i > 0)
			repeat_add[a[i] + a[i-1]]++;
		i++;
	}	
}

int main(int argc, char **argv) {
	int n_testcase, i_testcase;
	int i;

#ifdef INPUT_FILE
	fp = fopen(argv[1],"r");
	if (fp == NULL) {
		perror("Failed to open file");
		return;
	}
#endif

	fgets(buffer, sizeof(buffer), INPUT);
	sscanf(buffer, "%d", &n_testcase);
	for (i_testcase = 0; i_testcase < n_testcase; i_testcase++) {
		testcase_read();
#ifdef DEBUG
		printf("[TestCase %d]\n"
			   "n = %d\n"
			   "s = %d\n"
			   "an = %s", i_testcase, n, s, buffer);
		printf("go_through = %d\n"
			   "remainder = %d\n", go_through, remainder);
		printf("n_of_v[] = [%d, %d, %d]\n", n_of_v[0], n_of_v[1], n_of_v[2]);
		printf("repeat_add[] = [(0):%d, (1):%d, (2):%d, (3):%d, (4):%d]\n", repeat_add[0], repeat_add[1], repeat_add[2], repeat_add[3], repeat_add[4]);
#endif

		remainder = s - go_through;
		// Here start to logic process
		// Case 1
		if (remainder < 0)
			goto valid;

		// Case 2
		// s = go_through * (1 + 2*n), n = 0,1,2,3,...
		// remainder = s - go_through = go_through * 2 * n
		if ((remainder % go_through == 0) && 
			(remainder / go_through % 2 == 0))
			goto invalid;

		// Case 3: check current series
		if (check_arrange_good() == 1)
			goto valid;

		// Case 4: rearrange series
		for(i = 0; i < 5; i++)
			repeat_add[i] = 0;
		// Put 0 to the head very first
		for(i = 0; i < n; i++) {
			if (put_element(i, 0) != 1)
				break;
		}

		if (recv_f(i) == 0)
			goto invalid;
		
		for (i = 0; i < n; i++) {
			buffer[2*i] = a[i] + '0';
			buffer[2*i+1] = ' ';
		}
		buffer[2*i-1] = '\n';
		buffer[2*i] = '\0';
		goto valid;


invalid:
		printf("-1\n");
#ifdef DEBUG
		printf("\n\n");
#endif
		continue;

valid:
		printf("%s", buffer);
#ifdef DEBUG
		printf("\n\n");
#endif
		continue;

	}
	return 0;
}

int put_element(int index, int element) {
	if (n_of_v[element] <= 0)
		return 0;

	a[index] = element;
	n_of_v[element]--;
	if (index > 0)
		repeat_add[element + a[index - 1]]++;
	return 1;
}
void remove_element(int index, int element) {
	n_of_v[element]++;
	if (index > 0)
		repeat_add[element + a[index - 1]]--;
}
// Recursive function
int recv_f(int index) {
	int element;
	int ret;

	if (index == n)
		return 1;	// All elements been arranged well

	for (element = 1; element < 3; element++) {
		ret = put_element(index, element);
#ifdef DEBUG
		printf("put [element]%d to [index]%d, [return]%d\n", element, index, ret);
#endif
		if (ret != 1)	// put failed, cannot put
			continue;
		ret = check_arrange_good();
		if (ret == 1) {
			ret = recv_f(index + 1);
			if (ret == 1)
				return 1;
		}
#ifdef DEBUG
		printf("remove [element]%d from [index]%d\n", element, index);
#endif
		remove_element(index, element);
	}
	return 0;
}

int check_arrange_good(void) {
/*	return:
 *		0 can be compsed, bad arrange
 *		1 can not be compsed, good arrange
 * */
	//possible combination:
	//Pattern1: remainder = A1*1
	//Pattern2: remainder = A2*2 + A3*3
	//Pattern3: remainder = A2*2
	//Pattern4: remainder = A3*3
	//Pattern5: remainder = A3*3 + A4*4

	//Pattern1
	if (repeat_add[1]) {
#ifdef DEBUG
		printf("Pattern1 return\n");
#endif
		return 0;
	}
		
	//Pattern2
	//2 and 3 can compose any number over 2!!, only 1 success...
	if (repeat_add[2] && repeat_add[3] && 
		(remainder != 1)) {
#ifdef DEBUG
		printf("Pattern2 return\n");
#endif
		return 0;
	}

	//Pattern3
	if (repeat_add[2] && 
		(remainder % 2 == 0)) {
#ifdef DEBUG
		printf("Pattern3 return\n");
#endif
		return 0;
	}
	
	//Pattern4
	if (repeat_add[3] && 
		(remainder % 3 == 0)) {
#ifdef DEBUG
		printf("Pattern4 return\n");
#endif
		return 0;
	}

	//Pattern5
	// remainder%12 = 0~11
	// 0: return 1 in Pattern3
	// 1: return 0
	// 2: reutrn 0
	// 3: return 1 in Pattern3
	// 4: return 1
	// 5: return 0
	// 6: return 1 in Pattern3
	// 7: return 1
	// 8: return 1
	// 9: return 1 in Pattern3
	// 10: return 1
	// 11: return 1
	if (repeat_add[3] && repeat_add[4]) {
		if (remainder%12 != 1 && remainder%12 != 2 && remainder%12 != 5)
#ifdef DEBUG
			printf("Pattern5 return\n");
#endif
			return 0;
	}

	// Good arrange
	return 1;
}
